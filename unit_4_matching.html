<title>Unit 4 — Matching (Civil Liberties, Civil Rights, Judiciary)</title>
<style>
:root{
    --bg:#e5e7eb;
    --panel:#f9fafb;
    --ink:#111827;
    --muted:#6b7280;
    --accent:#2563eb;
    --ok:#16a34a;
    --bad:#dc2626;
    --tile:#ffffff;
    --tile-border:rgba(15,23,42,.12);
    --bg:#e5e7eb;           /* page background */
    --panel:#f9fafb;        /* card background */
    --ink:#111827;          /* main text */
    --muted:#6b7280;        /* muted text */
    --accent:#2563eb;       /* primary accent (blue) */
    --ok:#16a34a;           /* correct */
    --bad:#dc2626;          /* wrong */
    --tile:#ffffff;         /* answer tile */
    --tile-border:rgba(15,23,42,0.12);
}

*{box-sizing:border-box}

body{
margin:0;
font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
@@ -107,17 +109,24 @@
.drag-over{outline:2px dashed var(--accent)}
.correct{background:#dcfce7; border-color:#22c55e}
.wrong{background:#fee2e2; border-color:#ef4444}
  .answer{cursor:grab}
  .answer:active{cursor:grabbing}
  .answer{cursor:pointer} /* click-based now */
  .answer:active{cursor:pointer}

.sameHeight{height:var(--rowH,auto)}

  /* Click-select helpers (from Unit 3 style) */
  .selectable{cursor:pointer;}
  .selected-slot{outline:3px solid #2563eb; outline-offset:2px;}
  .pending-return{outline:3px dashed #dc2626; outline-offset:2px;}
</style>
</head>
<body>
<div class="wrap">
<h1>Unit 4 — Matching Practice</h1>
<p class="muted">
      Drag from <strong>Unused Answers</strong> into the <strong>Answer Slots</strong>. Each chapter has two rounds of 25; Unit 4 has six rounds of 25. Finish to see only missed items and retry just those.
      Click an <strong>Answer Slot</strong> in the middle, then click an answer in <strong>Unused Answers</strong> to fill it. 
      Click a filled answer to send it back to Unused. Each chapter has two rounds of 25; Unit 4 has six rounds of 25. 
      Finish to see only missed items and retry just those.
</p>

<!-- START -->
@@ -433,6 +442,9 @@ <h2 style="margin:0 0 6px">Round Complete</h2>
misses:[]
};

// selected slot index for click-select
let selectedSlot = null;

function bestKey(){ return `best_match_u4_${state.setKey}`; }
function startTimer(){
if(state.timer) clearInterval(state.timer);
@@ -483,6 +495,7 @@ <h2 style="margin:0 0 6px">Round Complete</h2>
state.missedOnly = fromMissed;
state.misses = [];
state.seconds = 0;
  selectedSlot = null;

document.getElementById('start').classList.add('hidden');
document.getElementById('result').classList.add('hidden');
@@ -538,8 +551,7 @@ <h2 style="margin:0 0 6px">Round Complete</h2>

if(ans){
const inner = document.createElement('div');
      inner.className = 'answer sameHeight';
      inner.setAttribute('draggable','true');
      inner.className = 'answer sameHeight selectable';
inner.dataset.key = ans.key;
inner.dataset.origin = 'center';

@@ -553,152 +565,107 @@ <h2 style="margin:0 0 6px">Round Complete</h2>
tx.textContent = ans.text;
inner.appendChild(tx);

      addAnswerDragHandlers(inner);
      // Click a filled answer to remove it back to bank
      inner.addEventListener('click', (e)=>{
        e.stopPropagation();
        const moved = state.center[idx];
        if(moved){
          state.center[idx] = null;
          state.right.push(moved);
          selectedSlot = idx; // keep slot focused for quick refill
          renderCenter();
          renderRight();
          updateProgress();
          requestAnimationFrame(equalizeHeights);
        }
      });

content.innerHTML = '';
content.appendChild(inner);
} else {
      content.innerHTML = '<span class="placeholder">Drop answer here</span>';
      content.innerHTML = '<span class="placeholder">Click an answer on the right</span>';
}

slot.appendChild(content);
    addSlotHandlers(slot);

    // Click slot to select it
    slot.addEventListener('click', ()=>{
      selectedSlot = idx;
      updateSelectedSlotHighlights();
      requestAnimationFrame(equalizeHeights);
    });

C.appendChild(slot);
});

  updateSelectedSlotHighlights();
}

function renderRight(){
const R = document.getElementById('right');
R.innerHTML = '';
state.right.forEach((item, idx)=>{
    const div = createAnswerNode(item, 'right', idx);
    div.classList.add('sameHeight');
    R.appendChild(div);
  });
}
    const div = document.createElement('div');
    div.className = 'answer selectable sameHeight';
    div.dataset.key = item.key;
    div.dataset.origin = 'right';

function createAnswerNode(item, origin, idx){
  const div = document.createElement('div');
  div.className = 'answer';
  div.setAttribute('draggable','true');
  div.dataset.key = item.key;
  div.dataset.origin = origin;

  const num = document.createElement('div');
  num.className = 'num';
  num.textContent = origin === 'right' ? String.fromCharCode(65+idx) : '⇄';

  const tx = document.createElement('div');
  tx.className = 'text';
  tx.textContent = item.text;

  div.appendChild(num);
  div.appendChild(tx);
  addAnswerDragHandlers(div);
  return div;
}
    const num = document.createElement('div');
    num.className = 'num';
    num.textContent = String.fromCharCode(65+idx);
    div.appendChild(num);

function updateProgress(){
  const total = state.center.length;
  const filled = state.center.filter(Boolean).length;
  document.getElementById('progress').textContent = `Filled ${filled} / ${total}`;
}
    const tx = document.createElement('div');
    tx.className = 'text';
    tx.textContent = item.text;
    div.appendChild(tx);

// ---- Drag & Drop ----
let dragData = null;

function addAnswerDragHandlers(node){
  node.addEventListener('dragstart', (e)=>{
    const key = Number(node.dataset.key);
    const origin = node.dataset.origin;
    dragData = {type:'answer', from:origin, key};
    if(origin === 'right'){
      const idx = [...node.parentNode.children].indexOf(node);
      dragData.fromIndex = idx;
    } else if(origin === 'center'){
      const slotIndex = state.center.findIndex(a => a && a.key === key);
      dragData.fromSlot = slotIndex;
    }
    node.classList.add('ghost');
    e.dataTransfer.effectAllowed = 'move';
  });
  node.addEventListener('dragend', ()=>{
    node.classList.remove('ghost');
    renumberRight();
    requestAnimationFrame(equalizeHeights);
  });
}
    // Click answer to place it into the selected slot
    div.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(selectedSlot === null) return;

function addSlotHandlers(slot){
  slot.addEventListener('dragover', (e)=>{
    e.preventDefault();
    slot.classList.add('drag-over');
  });
  slot.addEventListener('dragleave', ()=>{
    slot.classList.remove('drag-over');
  });
  slot.addEventListener('drop', (e)=>{
    e.preventDefault();
    slot.classList.remove('drag-over');
    if(!dragData || dragData.type !== 'answer') return;

    const targetSlot = Number(slot.dataset.slot);

    if(dragData.from === 'right'){
      const answerObj = state.right.splice(dragData.fromIndex,1)[0];
      if(state.center[targetSlot]){
        const displaced = state.center[targetSlot];
        state.center[targetSlot] = answerObj;
        state.right.splice(dragData.fromIndex,0,displaced);
      } else {
        state.center[targetSlot] = answerObj;
      const target = selectedSlot;

      // If slot already has an answer, return it to right bank
      if(state.center[target]){
        state.right.push(state.center[target]);
}
    } else if(dragData.from === 'center'){
      const fromSlot = dragData.fromSlot;
      const temp = state.center[targetSlot];
      state.center[targetSlot] = state.center[fromSlot];
      state.center[fromSlot] = temp || null;
    }

    renderCenter();
    renderRight();
    updateProgress();
    requestAnimationFrame(equalizeHeights);
  });
}
      // Remove this answer from right bank
      const key = item.key;
      const idxInRight = state.right.findIndex(a => a.key === key);
      if(idxInRight >= 0) state.right.splice(idxInRight,1);

      // Place into center
      state.center[target] = { key:item.key, text:item.text };

      // Clear selection
      selectedSlot = null;

// allow dropping back into "Unused Answers"
const rightBox = document.getElementById('right');
rightBox.addEventListener('dragover', (e)=>{
  e.preventDefault();
  rightBox.classList.add('drag-over');
});
rightBox.addEventListener('dragleave', ()=>{
  rightBox.classList.remove('drag-over');
});
rightBox.addEventListener('drop', (e)=>{
  e.preventDefault();
  rightBox.classList.remove('drag-over');
  if(!dragData || dragData.type !== 'answer') return;
  if(dragData.from === 'center'){
    const fromSlot = dragData.fromSlot;
    const moved = state.center[fromSlot];
    if(moved){
      state.center[fromSlot] = null;
      state.right.push(moved);
renderCenter();
renderRight();
updateProgress();
requestAnimationFrame(equalizeHeights);
    }
  }
});
    });

    R.appendChild(div);
  });
}

function renumberRight(){
  [...document.querySelectorAll('#right .answer .num')].forEach((n,i)=>{
    n.textContent = String.fromCharCode(65+i);
function updateSelectedSlotHighlights(){
  const slots = document.querySelectorAll('#center .slot');
  slots.forEach((slot, i)=>{
    slot.classList.toggle('selected-slot', i === selectedSlot);
});
}

function updateProgress(){
  const total = state.center.length;
  const filled = state.center.filter(Boolean).length;
  document.getElementById('progress').textContent = `Filled ${filled} / ${total}`;
}

function finish(){
stopTimer();
const total = state.center.length;
